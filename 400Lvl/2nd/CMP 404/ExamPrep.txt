CMP 404 EXAM PREP

Coverage
- Slide 1 to 4 (only)
----------------------------------------------------------------


SLIDE 1




SOFTWARE Engineering






1a. What is Software Design and Implementation?
ans: Software design and implementation is the stage in the software 
     engineering process at which an executable software system is 
     developed

a1. What is Software Design?
ans: Software design is a creative activity in which you identify 
     software components and their relationships, based on a customer’s 
     requirements. 

a2. What is Implementation?
ans: Implementation is the process of realizing the design as a program.

b. In a wide range of domains, it is possible to buy __________?
ans: off-the-shelf systems (COTS)

c. Off-the-shelf systems can be _______ and ________ to fit the users 
   requirements?
ans: adapted and tailored

d. Are off-the-shelf systems a cheaper and faster approach for most domains?
ans: Yes, they are

e. When we develop an application using off-the-shelf systems, the design  
   process becomes concerned with __________________?
ans: How to use the configuration features of that system to deliver the 
     system requirements.

f. Structured object-oriented design processes involve developing a number 
   of different ___________?
ans: System models

g. object-oriented design requires __________ for _________ and __________
   of its system models
ans: a lot of effort, the development, maintenance

h. Object-oriented design may not be ________ for small systems?
ans: cost-effective

i. For large systems developed by different groups _________ are an 
   important communication mechanism.
ans: design models

j. List 5 common activities in design processes?
ans: - Define the context and modes of use of the system,
     - Design the system architecture,
     - Identify the principal system objects,
     - Develop design models,
     - Specify object interfaces,

k. Why is understanding of the system context (relationships between the 
   software that is being designed and its external environment) essential?
ans: Because it helps in 
     - Deciding, how to provide the required system functionality 
     - How to structure the system to communicate with its environment
     - Establishing system boundaries (More: which helps in deciding what 
       features are implemented in the system being designed)

l. What is a System Context Model?
ans: It is a structural model that demonstrates how the other systems in the 
     environment of the system being developed

m. What is an Interaction Model?
ans: It is a dynamic model that shows how the system interacts with its 
     environment as it is used.

n. Draw a diagram showing the System Context for the Weather Station?
ans: Slide 1 (page 10)

o. Draw a diagram of the Weather Station Use Cases?
ans: Slide 1 (page 11)

p. Once interactions between the system and its environment have been 
   understood, What do we use the information for?
ans: We use it for designing the System Architecture

q. What do you do in Architectural Design?
ans: - You identify the major components that make up the system and their 
       interactions
     - Then you organize the components using an architectural pattern    
       (such as a layered or client-server model)

r. Draw the high-level Architecture of the weather station?
ans: Slide 1 (page 14)

s. What is the weather station composed of and how does it communicate?
ans: The weather station is composed of independent subsystems that 
     communicate by broadcasting messages on a common infrastructure.

t. Draw the Architecture of Data Collection?
ans: Slide 1 (page 15)

u. Is identifying of object classes in object oriented design difficult?
ans: Yes it is

v. Object class identification relies on?
ans: - Your skill
     - Your experience
     - Your domain knowledge of system designers

w. Object identification is an __________  process, that you are unlikely to get right the _____ time?
ans: Iterative, first

x. List the 4 approaches to Object identification?
ans: - Use a grammatical approach based on a natural language 
       description of the system (used in Hood OOD method)
     - Base the identification on tangible things in the application domain
     - Use a behavioral approach and identify objects based on what 
       participates in what behavior
     - Use a scenario-based analysis. The objects, attributes and methods 
       in each scenario are identified

y. What is a Weather Station?
ans: A weather station is a package of software controlled instruments 
     which collects data, performs some data processing and transmits 
     this data for further processing. 

y1. List the instruments used in the Weather Station?
ans: - Air thermometer
     - Ground thermometer
     - Anemometer,
     - A Wind vane
     - A Barometer and 
     - A rain gauge

y2. How often does the Weather Station collect data?
ans: Data is collected periodically

y3. When a command is issued to transmit the weather data
ans: The weather station processes and summarises the collected data. The 
     summarised data is transmitted to the mapping computer when a request 
     is received.

y4. What do you think the Object class identification of the Weather Station may be based on
ans: - Ground thermometer, Anemometer, Barometer:
       Application domain objects that are ‘hardware’ objects related to 
       the instruments in the system.
     - Weather station:
       The basic interface of the weather station to its environment. It 
       therefore reflects the interactions identified in the use-case model.
     - Weather data:
       Encapsulates the summarized data from the instruments.

z. Draw a diagram that shows the Weather Station Object Classes?
ans: Slide 1 (page 20)

Round 2
a. What do Design models really show?
ans: They show 
     - Objects 
     - Object classes and 
     - Relationships between these entities(or objects)

b. What do Static models describe?
ans: They describe the static structure of the system in terms of object 
     classes and relationships

c. What do Dynamic models describe? 
ans: They describe the dynamic interactions between objects

d. List 3 different examples of Design Models?
ans: - Subsystem models
     - Sequence models
     - State machine models
     Others include
     - Use-case models
     - Aggregation models
     - Generalization models

d1. Explain the 3 Design Models listed above?
ans: - Subsystem models that show logical groupings of objects into 
       coherent subsystems.
     - Sequence models that show the sequence of object interactions.
     - State machine models that show how individual objects change their 
       state in response to events.

e. Subsystem models show _________ of objects into ______________?
ans: Logical groupings, Coherent subsystems

e1. How are subsystem models shown in UML?
ans: They are shown using packages - an encapsulation construct

f. Sequence models show ________________.
ans: The sequence of object interactions

f1. Describe the layout of the Sequence model diagram?
ans: - Objects are arranged horizontally across the top;
     - Time is represented vertically so models are read top to bottom;
     - Interactions are represented by labelled arrows, Different styles of 
       arrow represent different types of interaction;
     - A thin rectangle in an object lifeline represents the time when the 
       object is the controlling object in the system.

f2. Draw an example sequence model diagram describing data collection?
ans: Slide 1 (page 25)

g1. State machine models show __________________.
ans: How individual objects change their state in response to events

g2. You don't usually need a state diagram. Why is this?
ans: - This is because many of the objects in a system are relatively 
       simple and
     - It adds unnecessary detail to the design

g1. Draw a State model diagram showing the Weather Station?
ans: Slide 1 (page 27) 

h. Why do Object Interfaces need to be specified?
ans: It needs to be specified so that the objects and other components 
     can be designed in parallel

i. Designers should avoid designing the interface representation, they 
   should instead __________?
ans: hide the interface representation in the object itself

j. Objects may have several interfaces which are ________________
ans: viewpoints on the methods provided

k. Draw a diagram of the Weather Station Interface?
ans: Slide 1 (page 29)











SLIDE 2





Design and Implementation





a. What is a Design Pattern?
ans: A design pattern is a way of reusing abstract knowledge about a 
     problem and its solution
     OR

b. What is a pattern?
ans: It is a description of the problem and the essence of its solution. It 
     should be sufficiently abstract to be reused in different settings.

c. Pattern descriptions usually makes use of _________ characteristics such 
   as ____________ and _____________?
ans: Object-oriented characteristics, Inheritance and polymorphism

d. List the Pattern elements?
ans: - Name
     - Problem description
     - Solution description
     - Consequences

e. Explain the Observer Pattern?
ans: - Name: Observer
     - Description: Separates the display of object state from the object 
                    itself
     - Problem description: Used when multiple displays of state are needed
     - Solution description: See slide with UML description.
     - Consequences: Optimizations to enhance display performance are 
                     impractical

e1. Draw a diagram of the Observer Pattern being used?
ans: Slide 2 (Page 8)

e2. Draw a UML model of the observer pattern?
ans: Slide 2 (page 9)

f. To use patterns in your design, you need to recognize that?
ans: Any design problem you are facing may have an associated pattern that 
     can be applied.

g. List 4 patterns?
ans: - Observer Pattern
     - Façade pattern
     - Iterator pattern
     - Decorator pattern

g1. Explain all 4 patterns above?
ans: - Observer Pattern: It tells several objects that the state of some 
       other object has changed
     - Façade pattern: Tidy up the interfaces to a number of related 
       objects that have often been developed incrementally
     - Iterator pattern: It provides a standard way of accessing the 
       elements in a collection, irrespective of how that collection is 
       implemented
     - Decorator pattern: It allows for the possibility of extending the 
       functionality of an existing class at run-time

g2. what are some implementation issues faced with implementing these 
    patterns?
ans: - Reuse
     - Configuration management
     - Host-target development

g3. Explain each of the issues listed above?
ans: - Reuse: Most modern software is constructed by reusing existing 
       components or systems. When you are developing software, you should 
       make as much use as possible of existing code
     - Configuration management: During the development process, you have 
       to keep track of the many different versions of each software 
       component in a configuration management system
     - Host-target development: Production software does not usually 
       execute on the same computer as the software development 
       environment. Rather, you develop it on one computer (the host 
       system) and execute it on a separate computer (the target system)

h. List the 5 different Reuse levels?
ans: - The abstraction level
     - The object level
     - The component level
     - The system level

h1. Explain what happens at every Reuse level
ans: - The abstraction level: At this level, you don’t reuse software 
       directly but use knowledge of successful abstractions in the design 
       of your software. 
     - The object level: At this level, you directly reuse objects from a 
       library rather than writing the code yourself. 
     - The component level: Components are collections of objects and 
       object classes that you reuse in application systems. 
     - The system level: At this level, you reuse entire application systems

h2. List 4 Reuse costs?
ans: - The costs of the time spent in looking for software to reuse and 
       assessing whether or not it meets your needs. 
     - Where applicable, the costs of buying the reusable software. For 
       larger off-the-shelf systems, these costs can be very high.
     - The costs of adapting and configuring the reusable software 
       components or systems to reflect the requirements of the system that you are developing.
     - The costs of integrating reusable software elements with each other 
       (if you are using software from different sources) and with the new 
       code that you have developed. 

i. Configuration management is the name given to the general process of 
   _____________?
ans: managing a changing software system

i1. What is the aim of Configuration Management?
ans: The aim of configuration management is to support the system 
     integration process so that all developers can access the project code 
     and documents in a controlled way, find out what changes have been 
     made, and compile and link components to create a system.

i2. List the 3 Problems of Configuration Management?
ans: - Version Management
     - System Integration
     - Problem tracking

i3. Explain all 3 problems above?
ans: - Version Management: where support is provided to keep track of the 
       different versions of software components. Version management 
       systems include facilities to coordinate development by several 
       programmers.
     - System Integration: where support is provided to help developers 
       define what versions of components are used to create each version 
       of a system. This description is then used to build a system 
       automatically by compiling and linking the required components.
     - Problem tracking: where support is provided to allow users to report 
       bugs and other problems, and to allow all developers to see who is 
       working on these problems and when they are fixed.

j. Most software is developed on one computer called ________, but runs on 
   a separate machine called ________
ans: The host, The target

j1. The host machine is also called the ____________ and the target machine 
    is also called the _________
ans: Development platform, Execution platform

j2. A platform is more than just hardware. It includes 
ans: The installed OS and other supporting software (such as a database 
     management system or, for development platforms an IDE)

j3. Development platform and Execution platform usually has different _________?
ans: Installed software and Architecture

j4. List 4 Development platform tools?
ans: - An integrated compiler and syntax-directed editing system that 
       allows you to create, edit and compile code.
     - A language debugging system.
     - Graphical editing tools (such as tools to edit UML models).
     - Testing tools (such as Junit that can automatically run a set of 
       tests on a new version of a program).
     - Project support tools that help you organize the code for different 
       development projects.

j5. What does the acronym IDE stand for?
ans: Integrated development environment

j5. What is an IDE?
ans: An IDE is a set of software tools that supports different aspects of 
     software development, within some common framework and user interface

j6. Why are IDE's created?
ans: To support development in a specific programming language such as 
     Java. The language IDE may be developed specially, or may be an 
     instantiation of a general-purpose IDE, with specific language-support 
     tools.

k. List the 3 Components/System deployment factors?
ans: - If a component is designed for a specific hardware architecture, or 
       relies on some other software system, it must obviously be deployed 
       on a platform that provides the required hardware and software 
       support
     - High availability systems may require components to be deployed on 
       more than one platform. This means that, in the event of platform 
       failure, an alternative implementation of the component is available.
     - If there is a high level of communications traffic between 
       components, it usually makes sense to deploy them on the same 
       platform or on platforms that are physically close to one other. 
       This reduces the delay between the time a message is sent by one 
       component and received by another.

l. What is Open Source Development?
ans: Open source development is an approach to software development in 
     which the source code of a software system is published and 
     volunteers are invited to participate in the development process

m. The best-known open source product is ____________?
ans: The linux operating system

m1. Linux is widely used as a ________ and __________?
ans: Server system, Desktop environment

n. List 3 other open source products?
ans: - Java
     - Apache web server
     - MySQL database management system

o. List the 2 open source issues?
ans: - Should the product that is being developed make use of open source 
       components?
     - Should an open source approach be used for the software’s 
       development?

p. Why do companies make their products open source?
ans: - Because their business model is not reliant on selling a software 
       product but on selling support for that product. 
     - They believe that involving the open source community will allow 
       software to be developed more cheaply, more quickly and will create a community of users for the software. 

q. A fundamental principle of open-source development is that source code 
   should be __________, it does not mean that _______________?
ans: freely available, anyone can do as they wish with that code

r. Discuss Open Source Licensing
ans: A fundamental principle of open-source development is that source 
     code should be freely available, this does not mean that anyone can do 
     as they wish with that code.
     - Legally, the developer of the code (either a company or an 
       individual) still owns the code. They can place restrictions on how 
       it is used by including legally binding conditions in an open source 
       software license. 
     - Some open source developers believe that if  an open source 
       component is used to develop a new system, then that system should 
       also be open source. 
     - Others are willing to allow their code to be used without this 
       restriction. The developed systems may be proprietary and sold as 
       closed source systems.

s. List 3 open source license models?
ans: - The GNU General Public License (GPL)
     - The GNU Lesser General Public License (LGPL)
     - The Berkley Standard Distribution (BSD) License

s1. Discuss all 3 license models above?
ans: - The GNU General Public License (GPL): This is a so-called 
       ‘reciprocal’ license that means that if  you use open source 
       software that is licensed under the GPL license, then you must make 
       that software open source. 
     - The GNU Lesser General Public License (LGPL): This is a variant of 
       the GPL license where you can write components that link to open 
       source code without having to publish the source of these 
       components. 
     - The Berkley Standard Distribution (BSD) License: This is a 
       non-reciprocal license, which means you are not obliged to 
       re-publish any changes or modifications made to open source code. 
       You can include the code in proprietary systems that are sold

t. List 5 ways for achieving License management
ans: - Establish a system for maintaining information about open-source 
       components that are downloaded and used. 
     - Be aware of the different types of licenses and understand how a 
       component is licensed before it is used. 
     - Be aware of evolution pathways for components. 
     - Educate people about open source. 
     - Have auditing systems in place. 
     - Participate in the open source community. 












SLIDE 3





Software Testing






3a.  Why do we need to Program Testing (or Testing)?
ans: Testing is intended to show that a program does what it is intended to 
     do and to discover program defects before it is put into use.

a1. When you test software, you execute a program using _____________
ans: artificial data

a2. You check the results of the test run for _______, _________ or 
    ___________
ans: - Errors
     - Anomalies
     - Information about the program’s non-functional attributes

a3. Testing is part of a more general _________ and _________ process?
ans: verification, validation

b. List the 2 goals of Program testing (or Testing)?
ans: - Validation testing
     - Defect testing

c. Explain validation testing (the 1st goal of testing) and defect testing 
   (the 2nd goal of testing)?
ans: - Validation testing: To demonstrate to the developer and the customer 
       that the software meets its requirements. A successful test shows 
       that the system operates as intended
     - Defect testing: To discover faults or defects in the software where 
       its behavior is incorrect or not in conformance with its 
       specification. A successful test is a test that makes the system 
       perform incorrectly and so exposes a defect in the system.

d. Draw a diagram of the input-output model of Program testing?
ans: Slide 3 (page 7)

e. Which of the options below refers to verification and validation (V&V), 
   individually?
   - "Are we building the product right" 
     The software should conform to its specification
   - "Are we building the right product" 
     The software should do what the user really requires

ans: - "Are we building the product right" (Verification)
     - "Are we building the right product" (Validation)

e1. What is the acronym V & V stand for?
ans: Verification and validation

e2. What is the aim of V & V confidence?
ans: It is to establish confidence that the system is ‘fit for purpose’

e3. V & V depends on 3 factors. List them?
ans: - Software purpose:  The level of confidence depends on how critical 
                          the software is to an organisation
     - User expectations: Users may have low expectations of certain kinds 
                          of software
     - Marketing environment: Getting a product to market early may be more 
                              important than finding defects in the program

f. What is Software Inspection?
ans: Software inspections is the analysis of the static system 
     representation to discover problems (static verification)

f1. What is Software testing?
ans: Software testing us concerned with executing and observing product 
     behavior (dynamic verification). The system is executed with test data and its behavior is observed

f2. Draw a diagram of Inspections and Testing?
ans: Slide 3 (page 11)

f3. Discuss Software Inspection?
ans: - These involve people examining the source representation with the 
       aim of discovering anomalies and defects.
     - Inspections dont require execution of a system so it may be used before 
       implementation.
     - They may be applied to any representation of the system 
       (requirements, design,configuration data, test data, etc.).
     - They have been shown to be an effective technique for discovering 
       program errors.

f4. List 3 Advantages of Inspections?
ans: - During testing, errors can mask (hide) other errors. Because 
       inspection is a static process, you don’t have to be concerned with 
       interactions between errors.
     - Incomplete versions of a system can be inspected without additional 
       costs. If a program is incomplete, then you need to develop 
       specialized test harnesses to test the parts that are available. 
     - Inspections can also consider broader quality attributes of a program, 
       such as compliance with standards, portability and maintainability

f5. Are the below statements true?
    - Inspections and testing are complementary and not opposing 
      verification techniques.
    - Both should be used during the V & V process.
    - Inspections can check conformance with a specification but not 
      conformance with the customer’s real requirements.
    - Inspections cannot check non-functional characteristics such as 
      performance, usability, etc.
ans: Yes they are

f6. Draw a diagram showing a model of the software testing process?
ans: Slide 3 (page 15)

g. List the 3 stages of testing?
ans: - Development testing
     - Release testing
     - User testing

g1. Explain each stage of testing?
ans: - Development testing: where the system is tested during development 
       to discover bugs and defects
     - Release testing: where a separate testing team test a complete 
       version of the system before it is released to users
     - User testing: where users or potential users of a system test the 
       system in their own environment

g1. During Development testing, there are different kinds of testing that 
    takes place. List only 3?
ans: - Unit testing
     - Component testing
     - System testing

g2. Explain all 3 testings listed above?
ans: - Unit testing: where individual program units or object classes are 
       tested. Unit testing should focus on testing the functionality of 
       objects or methods
     - Component testing: where several individual units are integrated to 
       create composite components. Component testing should focus on 
       testing component interfaces
     - System testing: where some or all of the components in a system are 
       integrated and the system is tested as a whole. System testing 
       should focus on testing component interactions

g3. What is Unit Testing?
ans: It is the process of testing individual components in isolation. 
     (It's a defect testing process)

g4. What are these units that are tested?
ans: - Individual functions or methods
     - Object classes (with several attributes and methods)
     - Composite components (with defined interfaces used to access their 
       functionality)

g5. Discuss Automated testing
ans: - Whenever possible, unit testing should be automated so that tests 
       are run and checked without manual intervention.
     - In automated unit testing, you make use of a test automation 
       framework (such as JUnit) to write and run your program tests. 
     - Unit testing frameworks provide generic test classes that you extend 
       to create specific test cases. They can then run all of the tests that you have implemented and report, often through some GUI

g6. Automated test components have 3 parts. Name them?
ans: - A Setup part
     - A Call part
     - An Assertion part

g7. Explain what happens in each part above?
ans: - A Setup part: where you initialize the system with the test case, 
       namely the inputs and expected outputs
     - A Call part: where you call the object or method to be tested
     - An Assertion part: where you compare the result of the call with 
       the expected result

g8. If the assertion evaluates to true, the test has been ________. If  
    false, then it has ________
ans: successful, failed

g9. List the effectiveness of Unit tests?
ans: - The test cases should show that, when used as expected, the 
       component that you are testing does what it is supposed to do
     - If there are defects in the component, these should be revealed by 
       test cases
     - This leads to 2 types of unit test case:
       - The first of these should reflect normal operation of a program 
         and should show that the component works as expected. 
       - The other kind of test case should be based on testing experience 
         of where common problems arise. It should use abnormal inputs to 
         check that these are properly processed and do not crash the 
         component.

h. List 2 Testing strategies?
ans: - Partition testing
     - Guideline-based testing

i. Explain both strategies above?
ans: - Partition testing: where you identify groups(or classes) of inputs 
       that have common characteristics and should be processed in the same 
       way
     - Guideline-based testing: where you use testing guidelines to choose 
       test cases

j. Discuss Partition testing further?
ans: - Input data and output results often fall into different classes 
       where all members of a class are related.
     - Each of these classes is an equivalence partition or domain where 
       the program behaves in an equivalent way for each class member.
     - Test cases should be chosen from each partition.

j1. Draw a diagram of Equivalence Partitioning?
ans: Slide 3 (page 27)

k. List 4 Sequence testing guidelines?
ans: - Test with sequences which have only a single value.
     - Use sequences of different sizes in different tests.
     - Derive tests so that the first, middle and last elements of the 
       sequence are accessed.
     - Test with sequences of zero length

l. List 5 General testing guidelines?
ans: - Choose inputs that force the system to generate all error messages 
     - Design inputs that cause input buffers to overflow 
     - Repeat the same input or series of inputs numerous times 
     - Force invalid outputs to be generated 
     - Force computation results to be too large or too small.












SLIDE 4





Software Testing







4a. Discuss Component Testing?
ans: Software components are often composite components that are made up of 
     several interacting objects
     You access the functionality of these objects through the defined component interface3a.  Why do we need to Program Testing (or Testing)?
ans: Testing is intended to show that a program does what it is intended to 
     do and to discover program defects before it is put into use.

     Testing composite components should therefore focus on showing that the component interface behaves according to its specification

b. Draw a diagram of Interface testing?
ans: Slide (page 3)

c. What is Interface Testing?
ans: It is a testing that aims to detect faults due to interface errors or 
     invalid assumptions about interfaces

c1. List the 4 Interface types?
ans: - Parameter interfaces
     - Procedural interfaces
     - Shared memory interfaces
     - Message passing interfaces

c2. Explain all Interface types above?
ans: - Parameter interfaces: Data passed from one method or procedure to 
       another.
     - Procedural interfaces: Sub-system encapsulates a set of procedures 
       to be called by other sub-systems.
     - Shared memory interfaces: Block of memory is shared between 
       procedures or functions.
     - Message passing interfaces: Sub-systems request services from other 
       sub-systems

c3. List 3 Interface Errors encountered?
ans: - Interface misuse
       A calling component calls another component and makes an error in 
       its use of its interface e.g. parameters in the wrong order.
     - Interface misunderstanding
       A calling component embeds assumptions about the behavior of the called component which are incorrect.
     - Timing errors
       The called and the calling component operate at different speeds and out-of-date information is accessed.

c4. List 5 Interface testing guidelines?
ans: - Design tests so that parameters to a called procedure are at the 
       extreme ends of their ranges.
     - Always test pointer parameters with null pointers.
     - Design tests which cause the component to fail.
     - Use stress testing in message passing systems.
     - In shared memory systems, vary the order in which components are 
       activated.

d. What is System Testing?
ans: System testing during development involves integrating components to 
     create a version of the system and then testing the integrated system.
     Additionally:
     - The focus in system testing is testing the interactions between 
       components. 
     - System testing checks that components are compatible, interact 
       correctly and transfer the right data at the right time across their 
       interfaces. 
     - System testing tests the emergent behavior of a system
     - During system testing, reusable components that have been separately 
       developed and off-the-shelf  systems may be integrated with newly 
       developed components. The complete system is then tested.
     - Components developed by different team members or sub-teams may be 
       integrated at this stage. System testing is a collective rather than 
       an individual process. 
       - In some companies, system testing may involve a separate testing 
         team with no involvement from designers and programmers. 

d2. Discuss Use-case testing?
ans: - The use-cases developed to identify system interactions can be used 
       as a basis for system testing.
     - Each use case usually involves several system components so testing 
       the use case forces these interactions to occur.
     - The sequence diagrams associated with the use case documents the 
       components and interactions that are being tested.

d3. Discuss Testing policies?
ans: - Exhaustive system testing is impossible so testing policies which 
       define the required system test coverage may be developed.
     - Examples of testing policies:
       - All system functions that are accessed through menus should be 
         tested.
       - Combinations of functions (e.g. text formatting) that are 
         accessed through the same menu must be tested.
       - Where user input is provided, all functions must be tested with 
         both correct and incorrect input.

e. What is Test-Driven Development (TDD)?
ans: Test-driven development (TDD) is an approach to software development 
     in which you inter-leave testing and code development.
     Additionally:  
     - Tests are written before code and ‘passing’ the tests is the 
       critical driver of development. 
     - You develop code incrementally, along with a test for that 
       increment. You don’t move on to the next increment until the code 
       that you have developed passes its test. 
     - TDD was introduced as part of agile methods such as Extreme 
       Programming. However, it can also be used in plan-driven development 
       processes.

e. Draw a diagram showing TDD?
ans: Slide 4 (page 13)

f. List the activities of the TDD process (Do this in order)?
ans: - Start by identifying the increment of functionality that is 
       required. This should normally be small and implementable in a few 
       lines of code.
     - Write a test for this functionality and implement this as an 
       automated test. 
     - Run the test, along with all other tests that have been implemented. 
       Initially, you have not implemented the functionality so the new 
       test will fail. 
     - Implement the functionality and re-run the test. 
     - Once all tests run successfully, you move on to implementing the 
       next chunk of functionality

g. List the Benefits of test-driven development (TDD)?
ans: - Code coverage
     - Regression testing
     - Simplified debugging
     - System documentation

g1. Explain the benefits above?
ans: - Code coverage: Every code segment that you write has at least one 
       associated test so all code written has at least one test
     - Regression testing: is testing the system to ensure that new code 
       changes have not ‘broken’ previously working code
     - Simplified debugging: When a test fails, it should be obvious where 
       the problem lies. The newly written code needs to be checked and 
       modified
     - System documentation: The tests themselves are a form of 
       documentation that describe what the code should be doing

g2. In a manual testing process, regression testing is ________ but, with 
    automated testing, it is ______ and __________.
ans: Expensive, Simple and Straightforward

g3. In automated testing, does all test rerun every time a change is made 
    to the program?
ans: Yes, they do

g4. Is it a must that all tests must run ‘successfully’ before the change 
    is committed?
ans: Yes, they do

h. What is Release Testing?
ans: It is the process of testing a particular release of a system that is 
     intended for use outside of the development team

h1. What is the primary goal of release testing?
ans: It is to convince the supplier of the system that it is good enough 
     for use
     Additionally:
     Release testing, therefore, has to show that the system delivers its 
     specified functionality, performance and dependability, and that it 
     does not fail during normal use

h2. Release testing is a form of ________ testing?
ans: System

h3. Release testing is usually a black-box testing process where tests are 
    only derived from the _________
ans: system specification

h4. What is the difference between release testing and system testing?
ans: - A separate team that has not been involved in the system 
       development, should be responsible for release testing.
     - System testing by the development team should focus on discovering 
       bugs in the system (defect testing). 
       
       The focus of release testing is to check that the system meets its 
       requirements and is good enough for external use (validation testing)

i. What is Requirements based testing?
ans: It is the examining of each requirement and developing a test for it

j. What is Performance testing?
ans: it is a test that usually involves planning a series of tests where 
     the load is steadily increased until the system performance becomes 
     unacceptable

k. What is Stress testing?
ans: it is a form of performance testing where the system is deliberately 
     overloaded to test its failure behavior

l. What is User or Customer testing?
ans: it is a stage in the testing process in which users or customers 
     provide input and advice on system testing
     Additionally:
     User testing is essential, even when comprehensive system and release 
     testing have been carried out. 
     - The reason for this is that influences from the user’s working 
       environment have a major effect on the reliability, performance, 
       usability and robustness of a system. These cannot be replicated 
       in a testing environment

l1. List the 3 types of User testing?
ans: - Alpha testing
     - Beta testing
     - Acceptance testing

l2. Explain each type of User testing?
ans: - Alpha testing: Users of the software work with the development team 
       to test the software at the developer’s site.
     - Beta testing: A release of the software is made available to users 
       to allow them to experiment and to raise problems that they 
       discover with the system developers.
     - Acceptance testing: Customers test a system to decide whether or 
       not it is ready to be accepted from the system developers and 
       deployed in the customer environment. Primarily for custom systems

l3. Draw a diagram showing The acceptance testing process?
ans: Slide 4 (page 26)

l4. List the 6 stages in Acceptance testing?
ans: - Define acceptance criteria
     - Plan acceptance testing
     - Derive acceptance tests
     - Run acceptance tests
     - Negotiate test results
     - Reject/accept system

m. How dos acceptance testing occur in the Agile methodology?
ans: - In agile methods, the user/customer is part of the development 
       team and is responsible for making decisions on the acceptability 
       of the system.
     - Tests are defined by the user/customer and are integrated with 
       other tests in that they are run automatically when changes are 
       made.
     - There is no separate acceptance testing process.
     - Main problem here is whether or not the embedded user is ‘typical’ 
       and can represent the interests of all system stakeholders.












SLIDE 5





Software evolution












5a. Discuss Software Change?
ans: - Software change is inevitable
       - New requirements emerge when the software is used;
       - The business environment changes;
       - Errors must be repaired;
       - New computers and equipment is added to the system;
       - The performance or reliability of  the system may have to be improved.
     - A key problem for all organizations is implementing and managing change 
       to their existing software systems.

b. List the importance  of Evolution?
ans: - Organizations have huge investments in their software systems - they 
       are critical business assets.
     - To maintain the value of  these assets to the business, they must be 
       changed and updated.
     - The majority of  the software budget in large companies is devoted to
       changing and evolving existing software rather than developing new 
       software.

c. Draw a diagram showing a spiral model of development and evolution?
ans: Slide 5 (page 5)

d. Draw a diagram showing evolution and servicing?
ans: Slide 5 (page 6)

d1. What takes place at Evolution?
ans: The stage in a software system’s life cycle where it is in operational 
     use and is evolving as new requirements are proposed and implemented in 
     the system

d2. What takes place at Servicing?
ans: At this stage, the software remains useful but the only changes made are 
     those required to keep it operational i.e. bug fixes and changes to 
     reflect changes in the software’s environment. No new functionality is 
     added

d3. What takes place at Phase-out?
ans: The software may still be used but no further changes are made to it.

e. Software evolution processes depend on. List all 3?
ans: - The type of  software being maintained;
     - The development processes used;
     - The skills and experience of  the people involved

f. Proposals for change are the driver for _________?
ans: system evolution

g. Change identification and evolution continues throughout __________?
ans: the system lifetime

h. Draw the diagram of Change identification and evolution processes?
ans: Slide 5 (page 9)

i. Draw the diagram of the software evolution process?
ans: Slide 5 (page 10)

j. Draw the diagram of Change Implementation?
ans: Slide 5 (page 11)

k. Discuss Change Implementation?
ans: - Iteration of the development process where the revisions to the system 
       are designed, implemented and tested.
     - A critical difference is that the first stage of  change implementation 
       may involve program understanding, especially if  the original system 
       developers are not responsible for  the change implementation. 
     - During the program understanding phase, you have to understand how the 
       program is structured, how it delivers functionality and how the 
       proposed change might affect the program

l. Urgent changes may have to be implemented without going through 
   ___________
ans: All stages of the software engineering process

m. What scenarios lead to Urgent change requests?
ans: - If  a serious system fault has to be repaired to allow normal operation 
       to continue;
     - If changes to the system’s environment (e.g. an OS upgrade) have 
       unexpected effects;
     - If  there are business changes that require a very rapid response (e.g. 
       the release of  a competing product)

n. Draw the diagram of repair process?
ans: Slide 5 (page 14)

o. Agile methods are based on incremental development so the transition from 
   development to evolution is ________?
ans: a seamless one

o1. Evolution for agile is simply a continuation of  the development process 
    based on _________
ans: Frequent system releases

p. Automated regression testing is particularly valuable when ____________
ans: Changes are made to a system

q. Where the development team have used an agile approach but the evolution 
   team is unfamiliar with agile methods and prefer a plan-based approach. 
   What happens in this Handover problem?
ans: The evolution team may expect detailed documentation to support evolution 
     and this is not produced in agile processes.

q1. Where a plan-based approach has been used for development but the 
    evolution team prefer to use agile methods. 
    What happens in this Handover problem?
ans: The evolution team may have to start from scratch developing automated 
     tests and the code in the system may not have been refactored and 
     simplified as is expected in agile development

r. What is Program evolution dynamics?
ans: Program evolution dynamics is the study of  the processes of  system 
     change.

r1. After several major empirical studies, Lehman and Belady proposed that 
    _____________
ans: There were a number of ‘laws’ which applied to all systems as they evolved

     Additionally:
     There are sensible observations rather than laws. They are applicable to 
     large systems developed by large organizations
     - It is not clear if  these are applicable to other types of  software 
       system

s. Systems MUST be changed if ______________
ans: they are to remain useful in an environment

t. List the Lehman's laws?
ans: - Continuing change
     - Increasing complexity
     - Large program evolution
     - Organizational stability
     - Conservation of familiarity
     - Continuing growth
     - Declining quality
     - Feedback system

t. Explain all laws listed above?
ans: - Continuing change: 
       A program that is used in a real-world environment must necessarily 
       change, or else become progressively less useful in that environment.
     - Increasing complexity: 
       As an evolving program changes, its structure tends to become more 
       complex. Extra resources must be devoted to preserving and simplifying 
       the structure.
     - Large program evolution:
       Program evolution is a self-regulating process. System attributes 
       such as size, time between releases, and the number of reported errors 
       is approximately invariant for each system release.
     - Organizational stability:
       Over a program’s lifetime, its rate of development is approximately 
       constant and independent of the resources devoted to system development.
     - Conservation of familiarity: 
       Over the lifetime of a system, the incremental change in each release 
       is approximately constant.
     - Continuing growth:
       The functionality offered by systems has to continually increase to 
       maintain user satisfaction.
     - Declining quality: 
       The quality of systems will decline unless they are modified to reflect 
       changes in their operational environment.
     - Feedback system: 
       Evolution processes incorporate multiagent, multiloop feedback systems 
       and you have to treat them as feedback systems to achieve significant 
       product improvement

u. Where is Lehman's Laws Applicable?
ans: Lehman’s laws seem to be generally applicable to large, tailored systems 
     developed by large organisations

v. Applicability of Lehman's Laws is not clear how they should be modified for?
     - Shrink-wrapped software products
     - Systems that incorporate a significant number of  COTS components
     - Small organisations
     - Medium sized systems

















